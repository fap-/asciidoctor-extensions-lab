require 'asciidoctor'
require 'pry'

# TEST:
# ~/repos/asciidoctor/bin/asciidoctor -r ./lib/multipage-html5-converter.rb -b multipage_html5 lib/multipage-html5-converter/Git/001_article.adoc

# Chunks the HTML output generated by the HTML5 converter by chapter.
#
# Usage
#
#   asciidoctor -r ./multipage-html5-converter.rb -b multipage_html5 book.adoc
#
# TODO
# * fix xrefs that span chapters
class MultipageHtml5Converter
  include Asciidoctor::Converter
  include Asciidoctor::Writer

  register_for 'multipage_html5'

  attr_reader :section_documents

  EOL = "\n"

  def initialize backend, opts
    super
    basebackend 'html'
    @section_documents = []
  end

  # calls the respective transform method for the specific node type (node_name)
  # eg., document or section
  def convert node, transform = nil
    transform ||= node.node_name
    send transform, node if respond_to? transform
  end

  def document node
#    binding.pry
    # calls convert for all blocks
    node.blocks.each {|b| b.convert }
    #node.blocks.clear
    master_content = []
    master_content << %(= #{node.doctitle})
    master_content << (node.attr 'author') if node.attr? 'author'
    master_content << ''
    # article top navigation / TOC
    @section_documents.each do |doc|
      sect = doc.blocks[0]
      sectnum = sect.numbered && !sect.caption ? %(#{sect.sectnum} ) : nil
      master_content << %(* <<#{doc.attr 'docname'}#,#{sectnum}#{sect.captioned_title}>>)
    end
    Asciidoctor.convert master_content, :doctype => node.doctype, :header_footer => true, :safe => node.safe
  end

  def section node
    doc = node.document
    # make extra document / file for this section
    page = Asciidoctor::Document.new [],
                                     :header_footer => true,
                                     :doctype => doc.doctype,
                                     :safe => doc.safe,
                                     :parse => true,
                                     :attributes => { 'noheader' => '', 'doctitle' => node.title, 'imagesdir' => (node.attr 'imagesdir') }
    page.set_attr 'docname', node.id
    # TODO recurse
    #node.parent = page
    #node.blocks.each {|b| b.parent = node }
    reparent node, page

#    binding .pry
    # last is a paragraph, so we are adding a block as line but here only inline passthrough works
    # better add a new block instead a new line
    # shouldn't this added to the document anyway?
    # TODO(fap): find out how/where the general document html layout is done
    last = node.blocks.last
    (last.lines << "\n++++\n<a href=\"./next.html\">next</a>\n++++") if last.respond_to? :lines

    # NOTE don't use << on page since it changes section number
    page.blocks << node
    @section_documents << page
    ''
  end

  # moves all children of the section to the new document
  def reparent node, parent
    node.parent = parent
    node.blocks.each do |block|
      reparent block, node unless block.context == :dlist
      if block.context == :table
        block.columns.each do |col|
          col.parent = col.parent
        end
        block.rows.body.each do |row|
          row.each do |cell|
            cell.parent = cell.parent
          end
        end
      end
    end
  end

  # def paragraph node
  #  puts 'here'
  # end

  def write output, target
    outdir = ::File.dirname target
    @section_documents.each do |doc|
      outfile = ::File.join outdir, %(#{doc.attr 'docname'}.html)
      ::File.open(outfile, 'w') do |f|
        f.write doc.convert
      end
    end
    chunked_target = target.gsub(/(\.[^.]+)$/, '-chunked\1')
    ::File.open(chunked_target, 'w') do |f|
      f.write output
    end
  end
end


module DocumentExtension

  def initialize data = nil, options = {}
    super
    @references[:id_origins] = {}
  end

  def register(type, value, force = false)
    if type == :ids
      id, origin = *value
      @references[:id_origins][id] = origin
    end
    super
  end
end

class Asciidoctor::Document
  prepend DocumentExtension
end
